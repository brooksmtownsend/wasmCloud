# protobuf-nats-service-generator

> [!WARNING]
> This crate is experimental and likely to experience breaking changes.

This crate is responsible for generating `Server` and `Client` traits from protobuf service definitions, enabling simple client-side requests using [async-nats](https://crates.io/crates/async-nats) and implementing and handling server-side requests using a generated trait.

## Usage

Add this crate's `protobuf_nats_service_generator::NatsServiceGenerator` to your `build.rs` file as a service generator. See the [prost_build](https://docs.rs/prost-build/latest/prost_build/) crate for more information on generating Rust types from .proto files.

```rust
use protobuf_nats_service_generator::NatsServiceGenerator;

fn main() -> std::io::Result<()> {
    // Find all the .proto files
    let protos = std::fs::read_dir("src")?
        .filter_map(|entry| {
            entry.ok().and_then(|e| {
                let path = e.path();
                if path.extension()?.to_str()? == "proto" {
                    Some(path)
                } else {
                    None
                }
            })
        })
        .collect::<Vec<_>>();

    prost_build::Config::new()
        .out_dir("src/generated")
        // Generate NATS client/server traits and implementations
        .service_generator(Box::new(NatsServiceGenerator))
        .compile_protos(&protos, &["src/"])?;
    Ok(())
}
```

## Example generated code

```rust
// This file is @generated by prost-build.
/// --------------------------------------------------------------
/// This file was generated by the `protobuf-nats-service-generator` crate
/// DO NOT MODIFY DIRECTLY
/// --------------------------------------------------------------
use anyhow::Context as _;
use futures::StreamExt;
use prost::Message;
/// CTL message to start component
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartComponentRequest {
    /// OCI image reference
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// Max number of instances to support scaling to
    #[prost(uint32, tag = "2")]
    pub max_instances: u32,
}
/// CTL message response to start component
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartComponentResponse {
    /// ID of the component we started
    #[prost(string, tag = "1")]
    pub component_id: ::prost::alloc::string::String,
    /// Error message if any
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// This will be used to implement the handlers for the client
pub trait ControlInterfaceServiceClient {
    /// Send request [StartComponentRequest], receiving the decoded [StartComponentResponse]
    #[allow(dead_code)]
    fn start_component(
        &self,
        _request: StartComponentRequest,
    ) -> impl ::futures::Future<
        Output = ::anyhow::Result<StartComponentResponse>,
    > + Send;
}
impl ControlInterfaceServiceClient for ::async_nats::Client {
    /// Send request [StartComponentRequest], decode response as [StartComponentResponse]
    async fn start_component(
        &self,
        request: StartComponentRequest,
    ) -> anyhow::Result<StartComponentResponse> {
        let mut buf = ::bytes::BytesMut::with_capacity(request.encoded_len());
        request.encode(&mut buf).context("failed to encode StartComponentRequest")?;
        let reply = self
            .request("wasmbus.ctl.proto.start.component", buf.into())
            .await
            .context("failed to send NATS request for start_component")?;
        StartComponentResponse::decode(reply.payload)
            .context("failed to decode reply as StartComponentResponse")
    }
}
/// This will be used to implement the handlers for the server
pub trait ControlInterfaceServiceServer {
    /// Implementation of StartComponent
    fn start_component(
        &self,
        _request: StartComponentRequest,
    ) -> impl ::futures::Future<
        Output = ::anyhow::Result<StartComponentResponse>,
    > + Send {
        async move { unimplemented!("StartComponent is not implemented") }
    }
}
#[allow(dead_code)]
pub async fn start_server<S>(
    server: S,
    client: async_nats::Client,
) -> ::anyhow::Result<impl ::futures::Future<Output = ::anyhow::Result<()>>>
where
    S: ControlInterfaceServiceServer + Send + 'static,
{
    let mut subscription = client
        .subscribe("wasmbus.ctl.proto.>")
        .await
        .context("failed to subscribe for ControlInterfaceService messages")?;
    Ok(async move {
        while let Some(message) = subscription.next().await {
            match message.subject.as_str() {
                "wasmbus.ctl.proto.start.component" => {
                    let request = StartComponentRequest::decode(message.payload)
                        .context(
                            "failed to decode message payload as StartComponentRequest",
                        )?;
                    let reply = server
                        .start_component(request)
                        .await
                        .context("failed to handle StartComponentRequest request")?;
                    if let Some(reply_to) = message.reply {
                        let mut buf = ::bytes::BytesMut::with_capacity(
                            reply.encoded_len(),
                        );
                        reply
                            .encode(&mut buf)
                            .expect("to encode without reaching capacity");
                        client
                            .publish(reply_to, buf.into())
                            .await
                            .context("failed to publish reply")?;
                    } else {
                        eprintln!("No reply subject found in message");
                    }
                }
                _ => {
                    eprintln!("Unknown subject: {}", message.subject);
                }
            }
        }
        Ok(())
    })
}

```

## Considerations

- [ ] How should we determine the subject prefix for subscriptions?

## Credit

Huge thanks to the [protobuf-zmq-rust-generator](https://crates.io/crates/protobuf-zmq-rust-generator) crate for inspiration and instructions.
